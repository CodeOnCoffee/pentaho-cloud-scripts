import os
import sys
import smtplib

from email import encoders
from email.message import Message
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import gzip
import zipfile
import tarfile
import tempfile
import glob
import shutil
import StringIO
import shlex
import subprocess
import string
import random

def gzip_func(ofile, value):
  gfile = gzip.GzipFile(fileobj=ofile, mode='wb')
  gfile.write(value)
  gfile.close()

def mk_multipart(file_mime_pairs, zip_func=gzip_func):
  """Create cloud-init multipart userdata.
  
  Based on cloudinit write-mime-multipart, which in turn was largely taken from python examples 
  http://docs.python.org/library/email-examples.html.
  
  Recognized mime types: text/x-include-url, text/x-shellscript, text/cloud-config, text/upstart-job, text/part-handler,
  text/cloud-boothook
  """
  outer = MIMEMultipart()

  for pair in file_mime_pairs:
    path, mtype = pair.split('|', 1)
    
    #print 'path=%s' % path
    #print 'mtype=%s' % mtype

    maintype, subtype = mtype.split('/', 1)
    if maintype == 'text':
      fp = open(path)
      # Note: we should handle calculating the charset
      msg = MIMEText(fp.read(), _subtype=subtype)
      fp.close()
    else:
      fp = open(path, 'rb')
      msg = MIMEBase(maintype, subtype)
      msg.set_payload(fp.read())
      fp.close()
      # Encode the payload using Base64
      encoders.encode_base64(msg)

    # Set the filename parameter
    msg.add_header('Content-Disposition', 'attachment', filename=os.path.basename(path))

    outer.attach(msg)

  ofile = StringIO.StringIO()
        
  zip_func(ofile, outer.as_string())
        
  contents = ofile.getvalue()
  ofile.close()
  return contents

def zip_func(ofile, value):
  """Not tested yet!"""
  z = zipfile.ZipFile(ofile, 'w')
  z.writestr('file1', value)

def mk_work_dir():
  """Create work directory and return path to it."""
  return tempfile.mkdtemp(prefix='pentaho-aws-', suffix='')

def rm_work_dir(work_dir):
  """Remove the work directory."""
  shutil.rmtree(work_dir)

def mk_license_tarball(work_dir, license_dir):
  """Create license tar.gz and return local path to tar.gz."""
  #print 'license_dir=%s' % license_dir
  
  # create tar file
  tar_file = tarfile.open(work_dir + '/pentaho-licenses.tar.gz', 'w:gz')

  # list all lic files
  files = glob.glob(license_dir + '/*.lic')
  for f in files:
    tar_file.add(f, arcname=os.path.basename(f))
 
  tar_file.close()
  return tar_file.name

def mk_vars_file(work_dir, server_cfg, provider_name):
  """Create a vars file and returns the local path to it."""
  f = open(work_dir + '/vars', 'w')
  f.write('# generated by pentaho_cloud')
  if (server_cfg.ssl):
    f.write('\nssl=1')
  else:
    f.write('\nssl=0')
  if server_cfg.passwords:
    for i, p in enumerate(server_cfg.passwords):
      f.write("\npasswords[%d]='%s'" % (i, p))
  packages = vers[server_cfg.version]
  for k in packages.keys():
    f.write("\n%s='%s'" % (k, packages[k]))
  f.write("\nprovider='%s'" % provider_name)
  f.close()
  return f.name

def mk_key_helper_jar(work_dir, res_dir):
  """Create ImportKey.jar in work directory and return local path to JAR.
  
  ImportKey.jar is used in the creation of SSL certificates based on IP address and not host name.
  """
  subprocess.call(['javac', '-d', work_dir, res_dir + '/ImportKey/comu/ImportKey.java'])
  subprocess.call(['jar', 'cfm', work_dir + '/ImportKey.jar', res_dir + '/ImportKey/manifest.txt', '-C', work_dir, 'comu/ImportKey.class'])
  return work_dir + '/ImportKey.jar'

def mk_passwd():
  return ''.join(random.choice(string.letters + string.digits) for i in xrange(8))

vers = {
  '4.0.0-GA':{        
    'biserver_deb':'pentaho-biserver-ee-4.0.0-all.deb',
    'pdd_deb':'pentaho-biserver-ee-plugin-pdd-4.0.0-all.deb',
    'paz_deb':'pentaho-biserver-ee-plugin-paz-4.0.0-all.deb',
    'pir_deb':'pentaho-biserver-ee-plugin-pir-1.0.0-all.deb',
    'diserver_deb':'pentaho-diserver-ee-4.2.0-all.deb',
    'pec_deb':'pentaho-enterprise-console-4.0.0-all.deb'
  },
  '4.1.0-GA':{
    'biserver_deb':'pentaho-biserver-ee-4.1.0-all.deb',
    'pdd_deb':'pentaho-biserver-ee-plugin-pdd-4.1.0-all.deb',
    'paz_deb':'pentaho-biserver-ee-plugin-paz-4.1.0-all.deb',
    'pir_deb':'pentaho-biserver-ee-plugin-pir-1.0.1-all.deb',
    'diserver_deb':'pentaho-diserver-ee-4.2.1-all.deb',
    'pec_deb':'pentaho-enterprise-console-4.1.0-all.deb'
  }
}

class PentahoServerConfig:
  """Server config."""
  ssl = False
  version = None
  license_dir = None
  res_dir = None
  passwords = ['password']

  def __init__(self, version, license_dir, res_dir, ssl=False, passwords = ['password']):
    self.version = version
    self.license_dir = license_dir
    self.res_dir = res_dir
    self.ssl = ssl
    self.passwords = passwords
